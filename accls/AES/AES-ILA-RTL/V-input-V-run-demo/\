// Include Ilated Model
#include "aes_ila.h"

// Include Verilated Impl
#include "aes_rtl.h"

// Include library
#include "verilated.h"
#include "verilated_vcd_c.h"
#include <fstream>
#include <iostream>
#include <nlohmann/json.hpp>

using json = nlohmann::json;

class Ilated;
class RTLVerilated;

#define AES_START 0xff00
#define AES_STATE 0xff01
#define AES_ADDR 0xff02
#define AES_LENGTH 0xff04
#define AES_KEY 0xff10
#define AES_CNT 0xff20

#define CMD_NOP 0
#define CMD_READ 1
#define CMD_WRITE 2

#define AES_STATE_IDLE 0
#define AES_STATE_READ_DATA 1
#define AES_STATE_OPERATE 2
#define AES_STATE_WRITE_DATA 3
// Util function




// Decl

void i_input(Ilated *i, i_in& test_input) {
  i->i_top->cmd = test_input.cmd;
  i->i_top->cmddata = test_input.cmddata;
  i->i_top->cmdaddr = tset_input.cmdaddr;
}

void next_instr(Ilated* i);
 
void next_instr(Ilated* i) {
  i->i_top->compute(); 
}


void check_state(Ilated* i, RTLVerilated* v, std::map<uint32_t, uint32_t>& store_trace);


void check_state(Ilated* i, RTLVerilated* v, std::map<uint32_t, uint32_t>& store_trace) {
// Architectural Level
  if (v->v_top->aes_top->aes_reg_opaddr_i->reg_out != i->i_top->AES_aes_address)
    std::cout << "Error address" << std::endl;
  if (v->v_top->aes_top->aes_reg_oplen_i->reg_out != i->i_top->AES_aes_length)
    std::cout << "Error length" << std::endl;
  if (v->v_top->aes_top->aes_reg_key0_i->reg_out[0] != ((uint32_t) i->i_top->AES_aes_key))
    std::cout << "Error key" << std::endl;

  if (v->v_top->aes_top->aes_reg_ctr_i->reg_out[0] != ((uint32_t) i->i_top->AES_aes_counter))
    std::cout << "Error counter" << std::endl;
  if (v->v_top->aes_top->aes_reg_state != (i->i_top->AES_aes_status))
    std::cout << "Error status" 
              << "v " << ((uint32_t) v->v_top->aes_top->aes_reg_state) 
              << "i " << i->i_top->AES_aes_status << std::endl;
  if (v->v_top->aes_top->data_out_reg != i->i_top->AES_outdata)
    std::cout << "Error data_out" << std::endl;
  for (auto it : store_trace) {
    if (i->i_top->AES_XRAM_next.update_map.find(it.first) == 
        i->i_top->AES_XRAM_next.update_map.end()) 
      std::cout << "Error st addr" << it.first << 
                   "update_map size" << i->i_top->AES_XRAM_next.update_map.size() << std::endl; 
    else {
      std::cout << "Correct st addr" << std::endl;
      // if (i->i_top->riscv_mem_next.update_map[it.first] !=
      //     it.second) 
      //   std::cout << "Error st data" << it.first << " " << it.second 
      //             << std::endl;
    }
  } 
/*
  if ((i->i_top->riscv_mem_next.original_map != i->i_top->riscv_mem)
      && (!store_trace.empty()))
    std::cout << "Error original map" << std::endl;
*/
  return;
}

int main(int argc, char **argv) {
  // Instantiate Model -- i
  Ilated* i = new Ilated;
  // Initialize Model -- i 

  // Instantiate Implementation -- v
  RTLVerilated* v = new RTLVerilated;

  /* verilog tv
  std::string tv_input;
  std::vector<uint32_t> tv;
  std::vector<mnt_instr*> fq;
  */
  // ila tv
  std::vector<v_in> tv_v;
  std::string t_input;

  // Initialize Implementation -- v
  v->v_top->rst = 1;
  next_cycle(v, fq);
  v->v_top->rst = 0;
  next_cycle(v, fq);
  // tmps
  
  // TODO(yuex): see if we want to use csv for tv.
  if (argc < 2) 
    std::cout << "Need test-vector input." << std::endl;
  // verilog tv
  std::ifstream tv_file;
  tv_file.open(argv[1]);
  
  int j = 0;
  while (getline(tv_file, t_input)) {
    v_in t_in;
    std::stringstream t_input_ss(t_input);
    std::string t_input_tt;
    if (getline(t_input, t_input_tt, ',')) {
      t_in.wr = std::stoul(t_input_tt, 0, 16); 
    } 
    if (getline(t_input, t_input_tt, ',')) {
      t_in.stb = std::stoul(t_input_tt, 0, 16); 
    } 
    if (getline(t_input, t_input_tt, ',')) {
      t_in.addr = std::stoul(t_input_tt, 0, 16); 
    } 
    if (getline(t_input, t_input_tt, ',')) {
      t_in.data_in = std::stoul(t_input_tt, 0, 16); 
    } 
    if (getline(t_input, t_input_tt, ',')) {
      t_in.xram_data_in = std::stoul(t_input_tt, 0, 16); 
    } 
    if (getline(t_input, t_input_tt, ',')) {
      t_in.xram_ack = std::stoul(t_input_tt, 0, 16); 
    } 
  }
  
  // ila tv  
  uint32_t i_lock_cycle = 0;
  for (auto t : tv) {
    // find instruction
    if (i_lock_cycle == 0) {
      i_in i_input;
      i_input.cmd = (t.wr == 1) ? 2 : 1;
      i_input.cmdaddr = t.addr;
      i_input.data_in = t.data_in;
      i_input(i, i_input);
      next_instr(i);
    } else {
      i_lock_cycle--;
    }
  }

  std::cout << "aes_end_address" << v->v_top->aes_top->aes_reg_opaddr_i->reg_out << std::endl; 

  exit(1);
  std::map<uint32_t, uint32_t> store_trace;
}  
  
  

